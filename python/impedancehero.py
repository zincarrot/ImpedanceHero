import numpy as np
import pandas as pd
import os.path
from lmfit import Parameters, minimize
import elements


class ImpedanceHero():
    def __init__(self, itype="fri") -> None:
        self.itype = itype

    def show_status(self):
        pass

    def set_type(self, itype):
        self.itype = itype

    def loadfile(self, fname, ftype="JiangLabVIEW",mean=True,screen=0.02):

        if ftype == "JiangLabVIEW":  # Jiang LabVIEW format
            self.data = self.load_jiang(fname,mean,screen)
        elif ftype == "fma":  # freq, magnitude, angle
            self.data = self.load_fma(fname)
        elif ftype == "fri":  # freq, real, imaginary
            self.data = self.load_fri(fname)

        if self.itype == "fma":
            self.fri2fma()
        
        return self.data

    def writefile(self, dest, ftype="csv"):
        if ftype == "csv":
            pd.DataFrame(self.data).to_csv(dest, index=None, header=None)

    def load_jiang(self, fname, mean=True, screen=0.02):
        imp_data = pd.read_excel(
            fname, index_col=None, engine="openpyxl").to_numpy()

        imp_data = np.reshape(imp_data, [imp_data.shape[0], len(self.frequencies), 5])[
            :, :, 2:4]
        imp_data[imp_data == 0] = np.nan
        imp_data[imp_data > 1e30] = np.nan

        if mean:
            processed_data = self.process_jiang_mean(imp_data, self.frequencies, screen)
        else:
            processed_data = self.process_jiang(imp_data, self.frequencies)
        return processed_data

    def load_fma(self, df):
        pass

    def load_fri(self, fname):
        return pd.read_csv(fname).to_numpy()

    def process_jiang_mean(self, raw_data, frequencies, screen=0.02):
        imp_mean = np.nanmean(raw_data, axis=0)
        imp_std = np.nanstd(raw_data, axis=0)
        processed_data = np.zeros((len(frequencies), 3))
        if (imp_std/imp_mean < screen).all():
            processed_data[:, 0] = frequencies
            processed_data[:, 1:] =imp_mean
        else:
            processed_data=None
        return processed_data

    def process_jiang(self, raw_data, frequencies):     # generated by chatGPT
        
        num_frequencies = raw_data.shape[1]
        num_measurements = raw_data.shape[0]
        frequencies = np.repeat(frequencies, num_measurements)
        processed_data = np.zeros((num_frequencies * num_measurements, 3))
        processed_data[:, 0] = frequencies
        processed_data[:, 1:] = np.transpose(raw_data,(1,0,2)).reshape(-1, 2)
        # print(processed_data)
        return processed_data

    def loadfreq_jiang(self, fname):
        with open(fname) as f:
            for line in f:
                if line.split(': ')[0] == 'Signal Frequency (Hz)':
                    flist = line.split(': ')[1].split('.000000')
                    flist.pop()
                    flist = [float(i) for i in flist]
                    # print(flist)
                    self.frequencies = flist
                    return flist

    def fri2fma(self):
        '''converts self.data from fri to fma'''
        imp_cplx = self.data[:, 1]+1j*self.data[:, 2]
        imp_mag = np.abs(imp_cplx)
        imp_ang = np.angle(imp_cplx, deg=True)
        self.data[:, 1] = imp_mag
        self.data[:, 2] = imp_ang

    def impedance_fit(self, data, model, inital_params, method):
        

        return minimize(model,params,method, nan_policy='omit')
        

    def plot_result():
        pass

    def build_model(self, circuit, name):
        self.params_names=""
        def parse_circuit(circuit):
            if type(circuit) == list:
                impedance = "( "
                for subcircuit in circuit:
                    new_impedance = parse_circuit(subcircuit)
                    impedance += new_impedance
                    impedance += " + "
                impedance = impedance[:-2]
                impedance += ")"
                return impedance

            elif type(circuit) == tuple:
                impedance = "1 / ( "
                for subcircuit in circuit:
                    impedance += "1 / ( "
                    new_impedance = parse_circuit(subcircuit)
                    impedance += new_impedance
                    impedance += " ) + "
                impedance = impedance[:-2]
                impedance += ")"
                return impedance
            
            elif type(circuit) == str:

                if circuit.startswith("CPE"):
                    self.params_names += f", {circuit.replace('CPE','Q')}, {circuit.replace('CPE','n')}"
                    return f"1 / ( p[\'{circuit.replace('CPE','Q')}\'] * ((2j * np.pi * f) ** p[\'{circuit.replace('CPE','n')}\']))"

                elif str(circuit).startswith("C"):
                    self.params_names += f", {circuit}"
                    return f"1 / (2j * np.pi * f * p[\'{circuit}\'])"

                elif circuit.startswith("R"):
                    self.params_names += f", {circuit}"
                    return f"p[\'{circuit}\']"

                elif circuit.startswith("L"):
                    self.params_names += f", {circuit}"
                    return f"2j * np.pi * f * p[\'{circuit}\']"

                else:
                    raise ValueError(f"Unsupported element: "+circuit)
            else:
                raise TypeError(f"Unsupported impedance type: {type(circuit)}")

        if not os.path.isfile("eq_models.py"):
            with open("eq_models.py", "w") as file:
                file.write("import numpy as np\n\n")
                file.close()

        with open("eq_models.py", "r") as file:
            if name in self.list_models():
                print("Model name already exists! No new model created")
                return
            print("Model name is available. Proceed to create new model")
            file.close()

        with open("eq_models.py", "a") as file:
            file.write("\n")
            parsed_str=parse_circuit(circuit)
            file.write("def "+name+f"(p, f): ")
            file.write("# "+str(circuit)+"\n")
            file.write("    return " + parsed_str)
            file.close()

    def list_models(self):
        mlist=[]
        with open("eq_models.py", "r") as file:
            for line in file.readlines():
                if line.startswith("def "):
                    mlist.append(line.split(" ")[1].split("(")[0])
            file.close()
        return mlist

    def get_model_layout(self, name):
        with open("eq_models.py", "r") as file:
            for line in file.readlines():
                if line.startswith("def "):
                    if line.split(" ")[1].split("(")[0] == name:
                        file.close()
                        return line.split("#")[-1][1:-1]
            

        # elif circuit.key()=="C":
        #     return 1/(2j*np.pi*freq*circuit.value())
        # elif circuit.key()=="R":
        #     return circuit.value()
        # elif circuit.key()=="L":
        #     return 2j*np.pi*freq*circuit.value()
        # elif circuit.key()=="E":
        #     return 1/(2j*np.pi*freq*circuit.value())
